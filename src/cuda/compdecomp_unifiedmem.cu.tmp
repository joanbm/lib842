#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>


#include "842-internal.h"

#define THREADS_PER_BLOCK 32
#define STRLEN 32
#define CHUNKS_PER_THREAD 32

#define CHECK_ERROR( err ) \
  if( err != cudaSuccess ) { \
    printf("Error: %s\n", cudaGetErrorString(err)); \
    exit( -1 ); \
  }

long long timestamp() {
	struct timeval te;
	gettimeofday(&te, NULL);
	long long ms = te.tv_sec * 1000LL + te.tv_usec/1000;
	return ms;
}

int nextMultipleOfChunkSize(unsigned int input) {
	unsigned int size = CHUNK_SIZE * CHUNKS_PER_THREAD * THREADS_PER_BLOCK;
	return (input + (size-1)) & ~(size-1);
} 

int main( int argc, const char* argv[])
{
	#ifdef STRICT
	printf("Running in strict mode (i.e. fully compatible to the hardware-based nx842 unit).\n");
	#endif
	uint8_t *in, *compressed, *decompressed;
	
	size_t ilen, olen, dlen;
	ilen = olen = dlen = 0;
	long long timestart_comp, timeend_comp;
	long long timestart_decomp, timeend_decomp;
	cudaError_t cuda_error;
	int count = 0;
	cudaGetDeviceCount(&count);
  	printf(" %d CUDA devices found\n", count);
  	if(!count)
    		::exit(EXIT_FAILURE);


	if(argc <= 1) {
		ilen = STRLEN;
		olen = ilen * 2;
		dlen = ilen;
		cudaMallocManaged(&in, ilen);
		cudaMallocManaged(&compressed, olen);
		cudaMallocManaged(&decompressed, dlen);
		memset(in, 0, ilen);
		memset(compressed, 0, olen);
		memset(decompressed, 0, dlen);

		uint8_t tmp[] = {0x30, 0x30, 0x31, 0x31, 0x32, 0x32, 0x33, 0x33, 0x34, 0x34, 0x35, 0x35, 0x36, 0x36, 0x37, 0x37, 0x38, 0x38, 0x39, 0x39, 0x40, 0x40, 0x41, 0x41, 0x42, 0x42, 0x43, 0x43, 0x44, 0x44, 0x45, 0x45};//"0011223344556677889900AABBCCDDEE";
		strncpy((char *) in, (const char *) tmp, STRLEN);

	} else if (argc == 2) {
		FILE *fp;
		fp=fopen(argv[1], "r");
		fseek(fp, 0, SEEK_END);
		unsigned int flen = ftell(fp);
		ilen = flen;
		printf("original file length: %d\n", ilen);
		ilen = nextMultipleOfChunkSize(ilen);
		printf("original file length (padded): %d\n", ilen);
		olen = ilen * 2;
		dlen = ilen;
		fseek(fp, 0, SEEK_SET);

                cudaMallocManaged(&in, ilen);
                cudaMallocManaged(&compressed, olen);
                cudaMallocManaged(&decompressed, dlen);

		//cudaMallocManaged(&in, ilen, cudaMemAttachHost);
		//cudaMallocManaged(&compressed, olen, cudaMemAttachHost);
		//cudaMallocManaged(&decompressed, dlen, cudaMemAttachGlobal);

		if(!fread(in, flen, 1, fp)) {
			fprintf(stderr, "FAIL: Reading file content to memory failed.\n");
		}
		fclose(fp);
	}

	if(ilen > CHUNK_SIZE) {
		printf("Using chunks of %d bytes\n", CHUNK_SIZE);

		uint32_t num_chunks = ilen / CHUNK_SIZE;
		uint64_t *compressedChunkPositions = (uint64_t*) malloc(sizeof(uint64_t) * num_chunks);
		uint32_t *compressedChunkSizes = (uint32_t*) malloc(sizeof(uint32_t) * num_chunks);
	
		timestart_comp = timestamp();
		#pragma omp parallel for
		for(uint32_t chunk_num = 0; chunk_num < num_chunks; chunk_num++) {
			
			size_t chunk_olen = CHUNK_SIZE * 2;
			uint8_t* chunk_in = in + (CHUNK_SIZE * chunk_num);
			uint8_t* chunk_out = compressed + ((CHUNK_SIZE * 2) * chunk_num);
			
			sw842_compress(chunk_in, CHUNK_SIZE, chunk_out, &chunk_olen);
			compressedChunkSizes[chunk_num] = chunk_olen;
		}
		timeend_comp = timestamp();

		const int chunks_per_kernel = CHUNKS_PER_THREAD * THREADS_PER_BLOCK;

		printf("Threads per Block: %d\n", THREADS_PER_BLOCK );
		printf("Number of Chunks: %d\n", num_chunks);
		printf("Number of Blocks: %d\n", chunks_per_kernel / THREADS_PER_BLOCK);
		printf("Chunks per Kernel: %d\n", chunks_per_kernel);
		printf("Kernel Invocations: %d\n", num_chunks / chunks_per_kernel);

		//cudaStreamAttachMemAsync(NULL, compressed, 0, cudaMemAttachGlobal);
		timestart_decomp = timestamp();
		for(int i = 0; i < num_chunks; i += chunks_per_kernel) {
			cuda842_decompress<<<chunks_per_kernel / THREADS_PER_BLOCK, THREADS_PER_BLOCK, 0>>>(((uint64_t *)compressed) + (i * (CHUNK_SIZE/8) * 2), ((uint64_t*) decompressed) + (i * (CHUNK_SIZE/8)));
		}
		cudaDeviceSynchronize();
		cuda_error = cudaGetLastError();
		CHECK_ERROR(cuda_error);
		timeend_decomp = timestamp();
		//cudaStreamAttachMemAsync(NULL, decompressed, 0, cudaMemAttachHost);

		/*
		timestart_decomp = timestamp();
                cuda842_decompress<<<num_chunks / THREADS_PER_BLOCK, THREADS_PER_BLOCK>>>((uint64_t*)compressed, (uint64_t*)decompressed);
                cudaDeviceSynchronize();
                cuda_error = cudaGetLastError();
                CHECK_ERROR(cuda_error);
                timeend_decomp = timestamp();
		*/

		printf("Compression performance: %lld ms / %f MiB/s\n", timeend_comp - timestart_comp, (ilen / 1024 / 1024) / ((float) (timeend_comp - timestart_comp) / 1000));
		printf("Decompression performance: %lld ms / %f MiB/s\n", timeend_decomp - timestart_decomp, (ilen / 1024 / 1024) / ((float) (timeend_decomp - timestart_decomp) / 1000));


	} else {

		sw842_compress(in, ilen, compressed, &olen);
        	cuda842_decompress<<<1,1>>>((uint64_t*)compressed, (uint64_t*)decompressed);
		cudaDeviceSynchronize();
        	cuda_error = cudaGetLastError();
		CHECK_ERROR(cuda_error);

	}
	
	if (memcmp(in, decompressed, ilen) == 0) {
		printf("Compression- and decompression was successful!\n");
	} else {
		fprintf(stderr, "FAIL: Decompressed data differs from the original input data.\n");
	}
	cudaFree(in);
	cudaFree(compressed);
	cudaFree(decompressed);

	printf("\n\n");
	return 0;
}
